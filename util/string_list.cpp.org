#include <stdlib.h>
#include <string.h>
#include "string_list.h"

const size_t string_list::DEFAULT_INDEX_ALLOCATION = 1000;
const size_t string_list::DEFAULT_DATA_ALLOCATION = 10 * 1024;
const size_t string_list::MAX_DATA_LOST = 1024;

string_list::string_list(bool sorted)
{
	_M_index_allocation = DEFAULT_INDEX_ALLOCATION;
	_M_data_allocation = DEFAULT_DATA_ALLOCATION;

	_M_sorted = sorted;

	_M_index = NULL;
	_M_size = 0;
	_M_used = 0;

	_M_data.data = NULL;
	_M_data.size = 0;
	_M_data.used = 0;
	_M_data.lost = 0;
}

string_list::string_list(unsigned index_allocation, unsigned data_allocation, bool sorted)
{
	_M_index_allocation = index_allocation;
	_M_data_allocation = data_allocation;

	_M_sorted = sorted;

	_M_index = NULL;
	_M_size = 0;
	_M_used = 0;

	_M_data.data = NULL;
	_M_data.size = 0;
	_M_data.used = 0;
	_M_data.lost = 0;
}

string_list::~string_list()
{
	clear();
}

void string_list::clear()
{
	if (_M_index) {
		free(_M_index);
		_M_index = NULL;
	}

	_M_size = 0;
	_M_used = 0;

	if (_M_data.data) {
		free(_M_data.data);
		_M_data.data = NULL;
	}

	_M_data.size = 0;
	_M_data.used = 0;
	_M_data.lost = 0;
}

void string_list::reset()
{
	_M_used = 0;
	_M_data.used = 0;
	_M_data.lost = 0;
}

bool string_list::exists(const char* string) const
{
	if ((!string) || (!*string)) {
		return false;
	}

	return exists(string, strlen(string));
}

bool string_list::exists(const char* string, size_t len) const
{
	if ((!string) || (!*string) || (len == 0)) {
		return false;
	}

	size_t position;
	return search(string, len, position);
}

const char* string_list::get_at(unsigned idx, size_t* len) const
{
	if (idx >= _M_used) {
		return false;
	}

	if (len) {
		*len = _M_index[idx].len;
	}

	return _M_data.data + _M_index[idx].string;
}

bool string_list::insert(const char* string)
{
	if ((!string) || (!*string)) {
		return false;
	}

	return insert(string, strlen(string));
}

bool string_list::insert(const char* string, size_t len)
{
	if ((!string) || (!*string) || (len == 0)) {
		return false;
	}

	size_t position;

	if (!_M_sorted) {
		position = _M_used;
	} else {
		if (search(string, len, position)) {
			return true;
		}
	}

	if ((!allocate()) || (!allocate_data(len + 1))) {
		return false;
	}

	if (position < _M_used) {
		memmove(&(_M_index[position + 1]), &(_M_index[position]), (_M_used - position) * sizeof(struct index));
	}

	memcpy(_M_data.data + _M_data.used, string, len);
	_M_index[position].string = _M_data.used;
	_M_data.used += len;
	_M_data.data[_M_data.used++] = 0;

	_M_index[position].len = len;

	_M_used++;

	return true;
}

bool string_list::remove(const char* string)
{
	if ((!string) || (!*string)) {
		return false;
	}

	return remove(string, strlen(string));
}

bool string_list::remove(const char* string, size_t len)
{
	if ((!string) || (!*string) || (len == 0)) {
		return false;
	}

	size_t position;

	if (!search(string, len, position)) {
		return false;
	}

	if (position < _M_used - 1) {
		memmove(&(_M_index[position]), &(_M_index[position + 1]), (_M_used - position - 1) * sizeof(struct index));
	}

	_M_data.lost += len;

	_M_used--;

	return defrag();
}

bool string_list::search(const char* string, size_t len, size_t& position) const
{
	const char* data = _M_data.data;

	if (!_M_sorted) {
		size_t i;
		for (i = 0; i < _M_used; i++) {
			if ((_M_index[i].len == len) && (strncasecmp(string, data + _M_index[i].string, len) == 0)) {
				position = i;
				return true;
			}
		}

		position = i;
	} else {
		int i = 0;
		int j = _M_used - 1;

		while (i <= j) {
			int pivot = (i + j) / 2;
			int ret = strncasecmp(string, data + _M_index[pivot].string, len);
			if (ret < 0) {
				j = pivot - 1;
			} else if (ret == 0) {
				if (len < _M_index[pivot].len) {
					j = pivot - 1;
				} else if (len == _M_index[pivot].len) {
					position = (size_t) pivot;
					return true;
				} else {
					i = pivot + 1;
				}
			} else {
				i = pivot + 1;
			}
		}

		position = (size_t) i;
	}

	return false;
}

bool string_list::allocate()
{
	if (_M_used == _M_size) {
		size_t size = _M_size + _M_index_allocation;
		struct index* index = (struct index*) realloc(_M_index, size * sizeof(struct index));
		if (!index) {
			return false;
		}

		_M_index = index;
		_M_size = size;
	}

	return true;
}

bool string_list::allocate_data(size_t len)
{
	size_t size = _M_data.used + len;
	if (size > _M_data.size) {
		size_t quotient = size / _M_data_allocation;
		size_t remainder = size % _M_data_allocation;
		if (remainder != 0) {
			quotient++;
		}

		size = quotient * _M_data_allocation;
		char* data = (char*) realloc(_M_data.data, size);
		if (!data) {
			return false;
		}

		_M_data.data = data;
		_M_data.size = size;
	}

	return true;
}

bool string_list::defrag()
{
	if (_M_data.lost < MAX_DATA_LOST) {
		return true;
	}

	size_t quotient = _M_data.used / _M_data_allocation;
	size_t remainder = _M_data.used % _M_data_allocation;
	if (remainder != 0) {
		quotient++;
	}

	size_t size = quotient * _M_data_allocation;
	char* data = (char*) malloc(size);
	if (!data) {
		return false;
	}

	char* old_data = _M_data.data;
	size_t used = 0;

	for (size_t i = 0; i < _M_used; i++) {
		memcpy(data + used, old_data + _M_index[i].string, _M_index[i].len + 1);
		_M_index[i].string = used;
		used += (_M_index[i].len + 1);
	}

	free(old_data);

	_M_data.data = data;
	_M_data.size = size;
	_M_data.used = used;
	_M_data.lost = 0;

	return true;
}
